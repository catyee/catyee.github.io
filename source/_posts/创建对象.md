---
title: 创建对象的几种方式
date: 2018-07-06 09:12:06
tags: JavaScript
categories: 前端学习笔记(JavaScript)
---

## 一般创建对象的方式
 在JavaScript中我们可以通过创建Object的实例和对象字面量这两种方式来创建单个对象。但是这两种方式有个缺点是: 在使用同一个接口创建多个对象时，会产生大量的重复代码
## 工厂模式
* 为了解决上述问题，引入了工厂模式。这种模式抽象了创建具体对象的过程，用函数来封装以待定接口创建对象的细节。代码示例如下:

```
    function CreatePerson(name, age, job){
        var o = new Object();
        o.name = name;
        o.age = age;
        o.job = job;
        o.sayName = function() {
            alert(this.name);
        }
        return o;
    }
    var person1 = createPerson('xiaohua', '20', 'singer');
    var person2 = createPerson('xiaohei','20', 'Solft Engineer');
```
* 上述代码通过同一个接口创建了多个相似的对象，但是通过这种方式创建的对象，我们并不能识别其类型
## 构造函数模式
* 通过构造函数模式我们可以创建特定类型的对象，像Object和Array这样的原生构造函数，在运行时，会自动出现在执行环境中，我们也可以来创建自定义的构造函数，从而定义自定义对象类型的属性和方法。代码实例如下:

```
    function Person(name, age, job) {
        this.name = name;
        this.age = age;
        this.job = job;
        this.sayName = function(){
            alert(this.name);
        }
    }
    var person1 = new Person('xiaohua', '20', 'singer');
    var person2 = new Person('xiaohei','20', 'Solft Engineer');
```
* 构造函数模式，我们约定函数名是大写。 使用new操作符来创建实例，以这种方式来调用构造函数会经历以下4个步骤:
- 创建一个新对象
- 将构造函数的作用域赋给新对象(即将this指向这个对象)
- 执行构造函数中的代码(为这个新对象添加属性)
- 返回新对象

* 在上面的例子中，person1和person2分别保存着Person的一个不同的实例。这两个对象都有一个constructor(构造函数)属性，该属性指向Person
    alert(person1.constructor == Person) // true
    alert(person2.constructor == Person) // true
    
    对象的constructor属性最初是用来标记对象类型的，但是检测对象类型的话，instanceof操作符更可靠一些。
* 创建自定义的构造函数意味着将来可以将它的实例标识为一种特定的类型，这正是构造函数模式胜过工厂模式的地方。
* 构造函数和其他函数的唯一区别就在于调用方式的不同。不过构造函数也是函数，不存在定义构造函数的特殊语法，任何函数，只要通过new操作符来调用，都可以作为构造函数，而任何函数，如果不通过new操作符调用，那么跟普通函数也没区别。例如上面的Person函数可以通过下列任何一种方式调用:
```
    // 当作构造函数使用
    var person = new Person('xiaohei','20', 'Solft Engineer');
    person.sayName();
    
    // 作为普通函数调用
    Person('xiaohei','20', 'Solft Engineer'); // 添加到window
    window.sayName();

    // 在另一个对象的作用域中调用
    var o = new Object();
    Person.call(o,'xiaohei','20', 'Solft Engineer');
    o.sayName();
```
### 构造函数的问题
* 构造函数虽然好用，但是也存在缺点。主要问题在于每个方法在每个实例上都要重新创建一遍。在前面的例子中，person1和person2都有一个名为sayName()的方法，但是这两个方法不是同一个Function的实例。ECMASript中的函数也是对象，因此每定义一个函数，也就是实例化了一个对象。从逻辑角度讲，此时的构造函数也可以这样定义
```
    function Person(name,age,job) {
        this.name = name;
        this.age = age;
        this.sayName = new Function("alert(this.name)");
    } 
```
以上表明，每个Person实例都包含一个不同的Function实例，但是创建两个完成同样任务的Function实例的确没有必要。我们可以采用下面这种方式来解决这个问题:

```
    function Person(name,age,job) {
        this.name = name;
        this.age = age;
        this.job = job;
        this.sayName = sayName;
    }
    function sayName() {
        alert(this.name);
    }
```
* 上面的这个例子中，Person的实例共享全局作用域中定义的sayName() 函数。但是这样的话，全局作用域中定义的函数实际上只能被某个对象所调用，这让全局作用域有点名不副实，而且如果对象需要定义很多方法，那么就需要定义很多个全局函数，这样我们这个自定义的引用类型就丝毫没有封装下而言了。

## 原型模式

* 原型模式可以解决构造函数模式中存在的问题。我们创建的每个函数都有一个prototype（原型）属性，这个属性是一个指针，指向一个对象，这个对象的用途是包含特定类型的所有实例共享的属性和方法。也就是说prototy就是该构造函数的实例的原型对象。代码示例如下:

```
    function Person() {

    }
    Person.prototype.name = 'xiaohua',
    Person.prototype.age = 20;
    Perosn.prototype.job = 'singer';
    Person.prototype.sayName = function() {
        alert(this.name);
    }
    var person1 = new Person();
    person1.sayName(); // "xiaohua"
    var person2 = new Person();
    person2.sayName(); //"xiaohua" 
    alert(person1.sayName == person2.sayName); //true 

```
- 上述person1和person2访问的都是同一组属性和同一个sayName()函数，要理解原型模式的工作原理，必须先理解ECMAScrit中原型对象的性质
### 理解原型对象
- 无论什么时候，只要创建了一个新函数，就会根据一组特定的规则为该函数创建一个prototype属性，这个属性指向函数的原型对象。在默认情况下，所有的原型对象都会自动获得一个constructor(构造函数)属性，这个属性包含一个指向prototype属性所在函数的指针。
- 创建了自定义的构造函数之后，其原型对象默认只会取得constructor属性，至于其他方法，则都是从Object继承而来的，当调用构造函数创建一个实例后，该实例的内部将包含一个指针(内部属性)，指向构造函数的原型对象。ECMA-262第五版中管这个指针叫做[[prototype]]。虽然在脚本中没有标准的方式访问，但FireFox，Safari和Chrome在每个对象上都支持一个属性__proto__；而在其他实现中，这个属性对脚本是完全不可见的，不过要明确的真正重要的一点是 **这个连接存在于实例和构造函数的原型对象之间，而不是存在于实例和构造函数之间**

- 我们可以通过isPrototypeOf()方法来确定对象原型是不是实例的原型对象。
                ```
                    alert(Person.prototype.isPrototypeof(person1)) // true
                ```
- 通过Object.getPrototypeOf()方法，可以回去实例的原型对象
                ```
                    alert(Object.getPrototypeOf(person1) == Person.prototype)
                ```
- **每当代码读取某个对象的某个属性时，都会执行一次搜索，搜索给定名字的属性所对应的属性值，搜索首先会从对象实例开始，如果在实例中找到了给定名字的属性，则返回该属性的值；如果没有找到，则继续搜索指针指向的原型对象，如果在原型对象中找到了，则返回这个值；这也就是多个对象实例共享原型所保存的属性和方法的基本原理，值得注意的是原型最初只包含constructor属性，它也是共享的，所以实例可以访问** 

- 虽然可以通过对象实例访问保存在原型中的值，但是却不能通过对象实例重写原型中的值，如果我们在实例中添加了一个属性，而该属性与实例原型中的一个属性同名，那我们就在实例中创建该属性，该属性会屏蔽原型中的那个属性。例如:
```
    function Person() {

    }
    Person.prototype.name = 'xiaohua',
    Person.prototype.age = 20;
    Perosn.prototype.job = 'singer';
    Person.prototype.sayName = function() {
        alert(this.name);
    }
    var person1 = new Person();
    var person2 = new Person();
    person1.name = "huahua";
    alert(person1.name); // "huahua"  来自实例
    alert(person2.name); // "xiaohua" 来自原型

    //delete删除实例属性，从而可以重新访问原型中的属性

    delete person1.name;
    alert(person1.name); // "xiaohua" 来自原型
```

- 使用hasOwnProperty()方法可以用来检测一个属性是存在于实例中还是存在于原型中。这个方法(不要忘了它是从Object继承来的)只在给定属性存在于对象实例中时，才会返回true。
            Object.getOwnPropertyDescriptor()方法只能用于实例属性，要去的原型属性的描述符，必须直接在原型对象上调用
### 原型与in操作符
- 有两种方式使用in操作符:单独使用和在for-in循环中使用。在单独使用时，in操作符会在通过对象能够访问给定属性时返回true，无论该属性存在于实例中还是原型中。
```
    function Person() {

    }
    Person.prototype.name = 'xiaohua',
    Person.prototype.age = 20;
    Perosn.prototype.job = 'singer';
    Person.prototype.sayName = function() {
        alert(this.name);
    }
    var person1 = new Person();
    var person2 = new Person();
    alert(person1.hasOwnProperty('name')); // false
    alert('name' in person); // true
    person1.name = "huahua";
    alert(person1.name); // huahua 来自实例
    alert(person1.hasOwnProperty(name)); // true
    alert('name' in person1) // true
    alert(person2.name) // 'xiaohua' 来自原型
    alert(person2.hasOwnProperty(name)); // false
    alert('name' in person2) // true
```
- 在使用for-in循环时，返回的是所有能够访问的、可枚举的属性，其中既包括存在于原型中的属性，也包括实例中的属性。屏蔽了原型中的不可枚举属性的实例属性也会在for-in循环中返回，因为根据规定，所有开发人员定义的属性都是可枚举的——ie8及更早版本除外（屏蔽不可枚举原型属性的实例属性不会出现在for-in循环中）
- 获取对象上所有可枚举的实例属性，可以使用Object.keys()方法，接收一个对象参数，返回一个包含所有可枚举属性的字符串数组。
- 获取所有的实例属性无论是否可枚举，使用Object.getOwnPropertyNames()
- 以上两个方法可以替代for-in循环 支持的浏览器有IE9+,Firefox4+，Safari5+，Opera12+，chrome
 ### 更简单的原型语法
 我们可以使用一种更简便的对象字面量写法来实现原型对象
```
    function Person() {

    }
    Person.prototype = {
        name: "huahua",
        age: 20,
        job: "singer",
        sayName: function() {
            alert(this.name)
        }
    }
```
**在上面的代码中，我们把Person.prototype设置为等于一个以对象字面量形式创建的对象。最终结果相同，但是需要注意的是：constructor属性不再指向Person了，前面曾经介绍过，每创建一个函数，就会同时创建它的prototype对象，这个对象也会自动获得constructor属性，而我们在这里使用的语法，本质上完全重写了默认的prototype对象，因此constructor属性也就变成了新对象的constructor属性（指向Object构造函数），不再指向Person函数** 可以手动给constructor赋值
```
    function Person() {

    }
    Person.prototype = {
        // 但是会导致[[enumerable]]属性被设置为true
        constructor: Person,
        name: "huahua",
        age: 20,
        job: "singer",
        sayName: function() {
            alert(this.name)
        }
    }
    var person1 = new Person(); // 创建指向原型的指针
    person1.__proto__ == Person.prototype // true
```
### 原型的动态性
由于在原型中查找值的过程是一次搜索，因此我们对原型对象所做的任何修改都能够立即从实例上反映出来
```
    var friend = new Person();
    Person.prototype.sayHi = function() {
        alert('hi');
    }
    friend.sayHi(); // "hi"
```
尽管可以随时为原型添加属性和方法，并且修改能够立即在所有对象实例中反映出来，但如果是重写整个原型对象，那么情况就不一样了。我们知道，调用构造函数时会为实例添加一个指向最初原型的[[Prototype]]指针，而把原型修改为另外一个对象就等于切断了构造函数与最初原型之间的联系。
```
function Person() {

}
var person1 = new Person(); // 创建指向原型的指针
Person.prototype = {
// 但是会导致[[enumerable]]属性被设置为true
constructor: Person,
name: "huahua",
age: 20,
job: "singer",
sayName: function() {
    alert(this.name)
}
}
person1.sayName(); // error
// 最初的原型对象 == 修改之后的原型对象 false
person1.__proto__ == Person.prototype // false 
```
### 原生对象的原型
原型模式的重要性不仅体现在创建自定义类型方面，就连所有原生的引用类型，都是采用这种模式创建的，例如在Array.prototype中可以找到sort()方法 在String.prototype中可以找到substring() 方法
我们也可以在原生对象的原型上添加或修改方法
### 原型对象的问题
原型模式的缺点: 首先，它省略了为构造函数传递初始化参数，这会导致所有的实例在默认情况下都将取得相同的属性值，其次，最大的问题是原型中的所有属性是被很多实例共享的，这种共享对于函数非常合适，对于包含基本值的属性也说得过去。然而，对于包含引用类型的值的属性来说就会出现问题了。如下:

```
    function Person() {

    }
    Person.prototype = {
        constructor: Person,
        name: "huahua",
        age: 20,
        job: "singer",
        friends: ["xiaohei","xiaolan"],
        sayName: function() {
            alert(this.name)
        }
    }
    var person1 = new Person();
    var person2 = new Person();
    person1.friends.push("xiaohong");
    alert(person1.friends); // ["xiaohei","xiaolan","xiaohong"]
    alert(person2.friends); // ["xiaohei","xiaolan","xiaohong"]
    alert(person1.friends === person2.friends); // true
```
上述对于原型对象中属性值是引用类型值的属性，在实例中修改的时候会影响其他的实例

## 组合使用构造函数模式和原型模式
创建自定义类型的最常见方式，就是组合使用构造函数模式与原型模式
**构造函数模式用于定义实例属性，而原型模式用于定义方法和共享的属性。**

```
    function Person(name,age,job) {
        this.name = name;
        this.age = age;
        this.job = job;
        this.friends = ['xiaohei','xiaolan'];
    }
    Person.prototype = {
        constructor: Person,
        sayName: function() {
            alert(this.name)
        }
    }
    var person1 = new Person('xiaohua', 20, 'singer');
    var person2 = new Person('xiaobai','21', 'queen');
    person1.friends.push('xiaohuang');
    alert(person1.friends); // ['xiaohei','xiaolan','xiaohuang'];
    alert(person2.friends); // ['xiaohei','xiaolan'];
    alert(person1.friends === person2.friends) // false
    alert(person1.sayName === person2.sayName) // true
```
## 动态原型模式
动态原型模式把所有的信息都封装在了构造函数中，而通过在构造函数中初始化原型又保持了构造函数和原型的优点，即通过检查某个应该存在的方法是否有效来决定是否需要初始化原型
```
    function Person(name,age,job) {
        // 属性
        this.name = name;
        this.age = age;
        this.job = job;
        // 方法
        if(typeof this.sayName != "function") {
            Person.prototype.sayName = function() {
                alert(this.name);
            }
        }
    }
    var person1 = new Person("huahua",20,'singer');
    perons1.sayName();
```
    以上这种方法对原型所做的修改能够立即在实例中得到反映，因此这种方法可以说非常完美，其中if语句检查的可以是初始化之后应该存在的任意属性和方法——不必用一大堆if语句检查每个属性和方法，只要检查其中一个即可，这种方式不能使用对象字面量重写原型，否则会切断实例和新原型的联系
## 寄生构造函数模式
通常在前述的几种模式都不适用的情况下，可以使用寄生构造函数模式，这种模式的基本思想是创建一个函数，该函数的作用仅仅是封装创建对象的代码，然再返回新创建的对象，但从表面上看，这个函数又很像典型的构造函数

```
    function Person(name,age,job) {
        var o = new Object();
        o.name = name;
        o.age = age;
        o.job = job;
        o.sayName = function() {
            alert(this.name);
        }
        return o;
    }
    var person1 = new Person('huahua','20','singer');
    friend.sayName(); // 'huahua'
```
这种方式除了调用的时候采用new操作符，跟工厂模式其实是一样的。构造函数在不返回值的情况下，默认会返回新的对象实例，而通过在构造函数的末尾添加一个return语句，可以重写调用构造函数时返回的值
这种模式可以在特殊的情况下用来为对象创建构造函数。假设我们想创建一个具有额外方法的特殊数组，由于不能直接修改Array构造函数，因此可以使用这个模式

```
    function SpecialArray() {
        // 创建数组
        var values = new Array();
        // 添加值
        values.push.apply(values,arguments);
        // 添加方法
        values.toPipedString = function() {
            return this.join("|");
        }
        return values;
    }
    var colors = new SpecialArray("red","bule","green");
    alert(colors.toPipedString()); // "red|bule|green"
```
寄生构造函数模式返回的对象与构造函数的原型属性之间没有关系，不能通过instanceof操作符来确定对象类型

## 稳妥构造函数模式
所谓稳妥构造函数模式指的是没有公共属性，而且其方法也不引用this的对象，最适合在一些安全的环境中(这些环境会禁止使用this和new)，或者在防止数据被其他应用程序（如Mashup）改动时使用。稳妥构造函数遵循与寄生构造函数类似的模式，但是有两点不同:一是新创建对象的实例方法不引用this 二是不使用new操作符调用构造函数

```
    function Person(name,age,job) {
        var o = new Object();
        o.name = name;
        o.age = age;
        o.job = job;
        o.sayName = function() {
            alert(name);
        }
        return o;
    }
    var person1 = new Person('huahua','20','singer');
    friend.sayName(); // 'huahua'
```
